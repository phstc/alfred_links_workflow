#
# Load required files.
#
require 'json'
require './helper'

#
# Process the command line.
#
query = ARGV.join(' ').strip

#
# Open and read in the json links file.
#
links = JSON.parse(File.read("#{$data_dir}/links.json"))

#
# Start the output of the xml according to:
# http://www.alfredforum.com/topic/5-generating-feedback-in-workflows/
#
output = %{<?xml version="1.0"?><items>}

#
# Setup our state machine variables for controlling the program. The number of
# parts generated by the split command is the state of the state machine.
#
parts = query.split("|")
num_parts = parts.count
regex = /#{parts[0]}.*/i         # This is a case insensitive search using the input as the match string.
item_count = 0

if num_parts > 1
	#
	# State 1:  This state is getting the information for a new link.
	#
	if num_parts == 2
		#
		# If this state has only two parts, then we still need the address. Ask the user for the
		# address.
		#
		output += %{
			<item uid="new" arg="" valid="no" autocomplete="#{parts[0]}|#{parts[1]}|n">
			<title>New Link Address: #{parts[1]}</title>
			<subtitle>Add new Link</subtitle>
			<icon>link.png</icon>
			</item>
		}
		item_count += 1
	else
		#
		# We have 3 parts! That means we have all the information and we can write it to the file.
		# Only write it to the file if the address does not already exist. Give the user a link to look
		# at the resulting address.
		#
		if not_in_links(links,parts[0])
			nlink = {}
			nlink['name'] = parts[0]
			nlink['href'] = parts[1]
			links["links"].push(nlink)
			File.write("#{$data_dir}/links.json",links.to_json)
		end
		output += %{
			<item uid="new" arg="#{parts[1]}" valid="yes" autocomplete="">
			<title>New Link Name: #{parts[0]}</title>
			<subtitle>New Link Address: #{parts[1]}</subtitle>
			<icon>link.png</icon>
			</item>
		}
		item_count += 1
	end
else
	#
	# State 2: This is the default state of listing every link in the links file. If the user has
	# typed anything, shrink the list based on those that match the name.
	#
	links["links"].each do  |link|
		name = link['name']
		href = link['href']

		if ! name.match(regex).nil?
			output += %{
				<item uid="#{name}" arg="#{href}" autocomplete="#{name}">
				<title>#{name}</title>
				<subtitle>#{href}</subtitle>
				<icon>link.png</icon>
				</item>
			}
			item_count += 1
		end
	end
end

if item_count < 1
	#
	# The above logic did not generate any output. Assume the user is giving a new label
	# and setup for the first state of the state machine.
	#
	output += %{
		<item uid="new" arg="" valid="no" autocomplete="#{parts[0]}|http://">
		<title>Link Name:  #{parts[0]}</title>
		<subtitle>Create a new Link</subtitle>
		<icon>link.png</icon>
		</item>
	}
end

#
# Close out the xml structure.
#
output += '</items>'

#
# Give Alfred the full xml structure.
#
puts output
